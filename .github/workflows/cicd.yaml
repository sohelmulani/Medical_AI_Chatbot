name: Deploy Application Docker Image to EC2 instance

# Trigger workflow whenever code is pushed to the main branch
on:
  push:
    branches: [main]
    paths-ignore:
      - "README.md"

jobs:
  Continuous-Integration:   # First job: Build & Push Docker image to Amazon ECR
    runs-on: ubuntu-latest   # Runs on GitHub-hosted Ubuntu runner

    steps:
      # Step 1: Checkout source code from repository
      - name: Checkout
        uses: actions/checkout@v3

      # Step 2: Configure AWS credentials using GitHub secrets
      # These secrets must be set in your repo settings
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      # Step 3: Login to Amazon ECR (Elastic Container Registry)
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Step 4: Build Docker image, tag it, and push to ECR
      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPO }}
          IMAGE_TAG: latest
        run: |
          # Build Docker image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          # Push image to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          # Save image reference for later jobs
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  Continuous-Deployment:    # Second job: Deploy image on EC2 (self-hosted runner)
    needs: Continuous-Integration   # Runs only after CI job succeeds
    runs-on: self-hosted            # Must be your EC2 instance registered as a GitHub runner

    steps:
      # Step 1: Checkout source code (optional, useful if you need files locally)
      - name: Checkout
        uses: actions/checkout@v3

      # Step 2: Configure AWS credentials again on EC2 runner
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      # Step 3: Login to Amazon ECR so EC2 can pull the image
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Step 4: Stop any container currently running on port 8080
      - name: Stop existing container on port 8080
        run: |
          CONTAINER_ID=$(docker ps -q --filter "publish=8080")
          if [ -n "$CONTAINER_ID" ]; then
            docker stop $CONTAINER_ID
            docker rm $CONTAINER_ID
          fi

      # Step 5: Run the new Docker container from ECR image
      - name: Run Docker Image to serve users
        run: |
          docker run -d \
            -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -e AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
            -e PINECONE_API_KEY="${{ secrets.PINECONE_API_KEY }}" \
            -e OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            -p 8080:8080 \
            "${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPO }}:latest"